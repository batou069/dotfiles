# Source the Nix-generated plugin configuration
# source = ~/.config/hypr/plugins-load.conf


# Sourcing external config files
$configs = $HOME/.config/hypr/configs # Default Configs directory path

source = configs/Keybinds.conf # Pre-configured keybinds

# ## This is where you want to start tinkering
$UserConfigs = $HOME/.config/hypr/UserConfigs # User Configs directory path
source = UserConfigs/Startup_Apps.conf # put your start-up packages on this file

source = UserConfigs/ENVariables.conf # Environment variables to load

#source= UserConfigs/Monitors.conf # Its all about your monitor config (old dots) will remove on push to main
#source= UserConfigs/WorkspaceRules.conf # Hyprland workspaces (old dots) will remove on push to main

source = UserConfigs/Laptops.conf # For laptop related

source = UserConfigs/LaptopDisplay.conf # Laptop display related. You need to read the comment on this file

source = UserConfigs/WindowRules.conf # all about Hyprland Window Rules and Layer Rules

source = UserConfigs/UserDecorations.conf # Decorations config file

source = UserConfigs/UserAnimations.conf # Animation config file



source = UserConfigs/UserSettings.conf # Main Hyprland Settings.

source = UserConfigs/01-UserDefaults.conf # settings for User defaults apps

# nwg-displays
source = monitors.conf
source = workspaces.conf

# plugin {
    # hyprexpo {
    #     columns = 3
    #     gap_size = 5
    #     bg_col = rgb(b50000)
    #     workspace_method = center current # [center/first] [workspace] e.g. first 1 or center m+1

    #     gesture_distance = 30000 # how far is the "max" for the gesture
    # }
    # # hyprscrolling {
    # #     column_width = 0.7
    # #     fullscreen_on_one_column = false
    # #     focus_fit_method = 1
    # # }
    # # dynamic-cursors {

    # #     # enables the plugin
    # #     enabled = true

    # #     # sets the cursor behaviour, supports these values:
    # #     # tilt    - tilt the cursor based on x-velocity
    # #     # rotate  - rotate the cursor based on movement direction
    # #     # stretch - stretch the cursor shape based on direction and velocity
    # #     # none    - do not change the cursors behaviour
    # #     mode = stretch

    # #     # minimum angle difference in degrees after which the shape is changed
    # #     # smaller values are smoother, but more expensive for hw cursors
    # #     threshold = 2

    # #     # override the mode behaviour per shape
    # #     # this is a keyword and can be repeated many times
    # #     # by default, there are no rules added
    # #     # see the dedicated `shape rules` section below!
    # #     # shaperule = <shape-name>, <mode> (optional), <property>: <value>, ...
    # #     # shaperule = <shape-name>, <mode> (optional), <property>: <value>, ...
    # #     # ...

    # #     # for mode = rotate
    # #     rotate {

    # #         # length in px of the simulated stick used to rotate the cursor
    # #         # most realistic if this is your actual cursor size
    # #         length = 20

    # #         # clockwise offset applied to the angle in degrees
    # #         # this will apply to ALL shapes
    # #         offset = 0.0
    # #     }

    # #     # for mode = tilt
    # #     tilt {

    # #         # controls how powerful the tilt is, the lower, the more power
    # #         # this value controls at which speed (px/s) the full tilt is reached
    # #         # the full tilt being 60Â° in both directions
    # #         limit = 5000

    # #         # relationship between speed and tilt, supports these values:
    # #         # linear             - a linear function is used
    # #         # quadratic          - a quadratic function is used (most realistic to actual air drag)
    # #         # negative_quadratic - negative version of the quadratic one, feels more aggressive
    # #         # see `activation` in `src/mode/utils.cpp` for how exactly the calculation is done
    # #         function = negative_quadratic

    # #         # time window (ms) over which the speed is calculated
    # #         # higher values will make slow motions smoother but more delayed
    # #         window = 100
    # #     }

    # #     # for mode = stretch
    # #     stretch {

    # #         # controls how much the cursor is stretched
    # #         # this value controls at which speed (px/s) the full stretch is reached
    # #         # the full stretch being twice the original length
    # #         limit = 3000

    # #         # relationship between speed and stretch amount, supports these values:
    # #         # linear             - a linear function is used
    # #         # quadratic          - a quadratic function is used
    # #         # negative_quadratic - negative version of the quadratic one, feels more aggressive
    # #         # see `activation` in `src/mode/utils.cpp` for how exactly the calculation is done
    # #         function = quadratic

    # #         # time window (ms) over which the speed is calculated
    # #         # higher values will make slow motions smoother but more delayed
    # #         window = 100
    # #     }

    # #     # configure shake to find
    # #     # magnifies the cursor if its is being shaken
    # #     shake {

    # #         # enables shake to find
    # #         enabled = true

    # #         # use nearest-neighbour (pixelated) scaling when shaking
    # #         # may look weird when effects are enabled
    # #         nearest = false

    # #         # controls how soon a shake is detected
    # #         # lower values mean sooner
    # #         threshold = 5.0

    # #         # magnification level immediately after shake start
    # #         base = 4.0
    # #         # magnification increase per second when continuing to shake
    # #         speed = 4.0
    # #         # how much the speed is influenced by the current shake intensitiy
    # #         influence = 0.0

    # #         # maximal magnification the cursor can reach
    # #         # values below 1 disable the limit (e.g. 0)
    # #         limit = 0.0

    # #         # time in millseconds the cursor will stay magnified after a shake has ended
    # #         timeout = 1000

    # #         # show cursor behaviour `tilt`, `rotate`, etc. while shaking
    # #         effects = true #false

    # #         # enable ipc events for shake
    # #         # see the `ipc` section below
    # #         ipc = false
    # #     }

    # #     # use hyprcursor to get a higher resolution texture when the cursor is magnified
    # #     # see the `hyprcursor` section below
    # #     hyprcursor {

    # #         # use nearest-neighbour (pixelated) scaling when magnifing beyond texture size
    # #         # this will also have effect without hyprcursor support being enabled
    # #         # 0 / false - never use pixelated scaling
    # #         # 1 / true  - use pixelated when no highres image
    # #         # 2         - always use pixleated scaling
    # #         nearest = true

    # #         # enable dedicated hyprcursor support
    # #         enabled = true

    # #         # resolution in pixels to load the magnified shapes at
    # #         # be warned that loading a very high-resolution image will take a long time and might impact memory consumption
    # #         # -1 means we use [normal cursor size] * [shake:base option]
    # #         resolution = -1

    # #         # shape to use when clientside cursors are being magnified
    # #         # see the shape-name property of shape rules for possible names
    # #         # specifying clientside will use the actual shape, but will be pixelated
    # #         fallback = clientside
    # #     }
    # # }

    # hy3 {
    #     # disable gaps when only one window is onscreen
    #     # 0 - always show gaps
    #     # 1 - hide gaps with a single window onscreen
    #     # 2 - 1 but also show the window border
    #     no_gaps_when_only = 0 # default: 0

    #     # policy controlling what happens when a node is removed from a group,
    #     # leaving only a group
    #     # 0 = remove the nested group
    #     # 1 = keep the nested group
    #     # 2 = keep the nested group only if its parent is a tab group
    #     node_collapse_policy = 2 # default: 2

    #     # offset from group split direction when only one window is in a group
    #     group_inset = 10 # default: 10

    #     # if a tab group will automatically be created for the first window spawned in a workspace
    #     tab_first_window = false

    #     # tab group settings
    #     tabs {
    #       # height of the tab bar
    #       height = 22 # default: 22

    #       # padding between the tab bar and its focused node
    #       padding = 6 # default: 6

    #       # the tab bar should animate in/out from the top instead of below the window
    #       from_top = false # default: false

    #       # radius of tab bar corners
    #       radius = 6 # default: 6

    #       # tab bar border width
    #       border_width = 2 # default: 2

    #       # render the window title on the bar
    #       render_text = true # default: true

    #       # center the window title
    #       text_center = true # default: true

    #       # font to render the window title with
    #       text_font = Sans # default: Sans

    #       # height of the window title
    #       text_height = 8 # default: 8

    #       # left padding of the window title
    #       text_padding = 3 # default: 3

    #       # active tab bar segment colors
    #     #   col.active = <color> # default: rgba(33ccff40)
    #     #   col.active.border = <color> # default: rgba(33ccffee)
    #     #   col.active.text = <color> # default: rgba(ffffffff)

    #       # active tab bar segment colors for bars on an unfocused monitor
    #     #   col.active_alt_monitor = <color> # default: rgba(60606040)
    #     #   col.active_alt_monitor.border = <color> # default: rgba(808080ee)
    #     #   col.active_alt_monitor.text = <color> # default: rgba(ffffffff)

    #       # focused tab bar segment colors (focused node in unfocused container)
    #     #   col.focused = <color> # default: rgba(60606040)
    #     #   col.focused.border = <color> # default: rgba(808080ee)
    #     #   col.focused.text = <color> # default: rgba(ffffffff)

    #       # inactive tab bar segment colors
    #     #   col.inactive = <color> # default: rgba(30303020)
    #     #   col.inactive.border = <color> # default: rgba(606060aa)
    #     #   col.inactive.text = <color> # default: rgba(ffffffff)

    #       # urgent tab bar segment colors
    #     #   col.urgent = <color> # default: rgba(ff223340)
    #     #   col.urgent.border = <color> # default: rgba(ff2233ee)
    #     #   col.urgent.text = <color> # default: rgba(ffffffff)

    #       # urgent tab bar segment colors
    #     #   col.locked = <color> # default: rgba(90903340)
    #     #   col.locked.border = <color> # default: rgba(909033ee)
    #     #   col.locked.text = <color> # default: rgba(ffffffff)

    #       # if tab backgrounds should be blurred
    #       # Blur is only visible when the above colors are not opaque.
    #       blur = true # default: true

    #       # opacity multiplier for tabs
    #       # Applies to blur as well as the given colors.
    #       opacity = 1.0 # default: 1.0
    #     }

    #     # autotiling settings
    #     autotile {
    #       # enable autotile
    #       enable = true # default: false

    #       # make autotile-created groups ephemeral
    #       ephemeral_groups = true # default: true

    #       # if a window would be squished smaller than this width, a vertical split will be created
    #       # -1 = never automatically split vertically
    #       # 0 = always automatically split vertically
    #       # <number> = pixel width to split at
    #       trigger_width = 0 # default: 0

    #       # if a window would be squished smaller than this height, a horizontal split will be created
    #       # -1 = never automatically split horizontally
    #       # 0 = always automatically split horizontally
    #       # <number> = pixel height to split at
    #       trigger_height = 0 # default: 0

    #       # a space or comma separated list of workspace ids where autotile should be enabled
    #       # it's possible to create an exception rule by prefixing the definition with "not:"
    #       # workspaces = 1,2 # autotiling will only be enabled on workspaces 1 and 2
    #       # workspaces = not:1,2 # autotiling will be enabled on all workspaces except 1 and 2
    #       workspaces = all # default: all
    #     }
    #   }
debug:disable_logs = false
debug:enable_stdout_logs = true
    # }
source = UserConfigs/UserKeybinds.conf # Put your own keybinds here
# = Source for hyprviz
source = ./hyprviz/Hyprviz.conf
